import { Meta, Story, Canvas, Controls } from '@storybook/addon-docs/blocks';
import * as TextInputStories from './TextInput.stories';
import { TextInput } from './TextInput';
import { CustomTabs, Tab } from '../../../../.storybook/CustomTabs';

<Meta title='Components/TextInput' of={TextInputStories} />

# ‚å®Ô∏è TextInput

<CustomTabs>
  <Tab label="Overview">

## Introduction

Input fields are essential form elements that enable users to enter and edit text. This component features a floating label, error states, and an automatic clear button for enhanced user experience.
It also provides the ability to add custom elements on the right side of the input.

> View in [Figma](https://www.figma.com/design/JxaLVMTWirCpU0rsbZ30k7/2.-Components-Library?node-id=6375-6974&m=dev).

## Anatomy

<Canvas of={TextInputStories.Default} />
<Controls of={TextInputStories.Default} />

> **Layout:** The Input component takes the full width of its container by default. You can control the width directly using `className` or by wrapping in a container.

### Clear Button

A clear button (√ó) appears **automatically** when input has content.

<Canvas of={TextInputStories.WithContent} />

> **Note:** The clear button only clears the input content/value. It does not clear error states - you must handle error state clearing separately in your component logic.

#### **Hiding the Clear Button**

Use `hideClearButton` to prevent the clear button from appearing:

<Canvas of={TextInputStories.HiddenClearButton} />

#### **Extending the Clear Behavior**

Use `onClear` to extend the default clear behavior with custom logic:

<Canvas of={TextInputStories.ExtendedClearBehavior} />

### Error State

The input supports error handling through:

- `aria-invalid`: Controls the error state styling
- `errorMessage`: Displays an error message below the input
- Error styling includes a red ring and text color

<Canvas of={TextInputStories.WithError} />

The error message will be automatically:

- Connected to the input using aria-describedby
- Displayed with a warning icon
- Styled in the error color
- Announced by screen readers

### Custom Right Element

The input supports custom interactive elements on the right side through the `suffix` prop:

<Canvas of={TextInputStories.WithCustomElement} />

You can add: Tooltips, Action buttons, Custom icons, Any interactive element

> **Important note:** The clear button automatically appears when input has content and will take priority over your `suffix`. Use `hideClearButton` to prevent this if you need persistent right-side content.

### Interactive in a Form

<Canvas of={TextInputStories.Interactive} />

## Input Types

The component supports various HTML input types:

- text (default)
- email
- password
- number
- tel
- url

## Accessibility

The Input component follows accessibility best practices:

- Uses semantic HTML with proper ARIA attributes
- Supports keyboard navigation
- Labels are properly associated with inputs using htmlFor
- Error messages are linked to inputs using aria-describedby
- Clear button has an accessible label
- Error states are communicated through aria-invalid

## Controlled vs Uncontrolled

The Input component supports both controlled and uncontrolled usage:

### Uncontrolled (with defaultValue)

<Canvas of={TextInputStories.UncontrolledInputExample} />

### Controlled (with value and onChange)

<Canvas of={TextInputStories.ControlledInputExample} />

## Label vs Placeholder

> ‚ö†Ô∏è **Important:** Do not combine `label` and `placeholder` props together. They will visually overlap and create a poor user experience.

The Input component uses **floating labels** that animate from inside the input field. Using both label and placeholder simultaneously will cause them to overlap and interfere with each other.

## Best Practices

**Labels**: Always provide clear, descriptive labels

**Error Messages**: Make error messages helpful and actionable

**Validation**: Validate on blur or submit, not on every keystroke

**Clear Button**: Use for optional fields where clearing is helpful

**Types**: Use the appropriate input type for the data being collected

**Label vs Placeholder**: Choose one approach - don't mix floating labels with placeholders

</Tab>
<Tab label="Implementation">

```bash
npm install @ledgerhq/ldls-ui-react
```

> **Note**: `@ledgerhq/ldls-design-core` and other peer dependencies (`react`, `tailwindcss`, `clsx`, etc.) are required. See our [Setup Guide ‚Üí](?path=/docs/getting-started-setup-tailwind--docs#1-tailwind-config) for complete installation and Tailwind configuration.

## Basic Usage

```tsx
import { TextInput } from '@ledgerhq/ldls-ui-react';

function MyComponent() {
  const [value, setValue] = React.useState('');

  return (
    <TextInput
      label='Username'
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

> **Note:** Clear button appears automatically when input has content. Use `hideClearButton` to hide it.

#### **Hiding the Clear Button**

Use `hideClearButton` to prevent the clear button from appearing:

```tsx
import { TextInput } from '@ledgerhq/ldls-ui-react';

function MyComponent() {
  const [value, setValue] = React.useState('');

  return (
    <TextInput
      label='Username'
      value={value}
      onChange={(e) => setValue(e.target.value)}
      hideClearButton // Clear button will not appear
    />
  );
}
```

#### **Extending the Clear Behavior**

Provide `onClear` to extend the default clear behavior with additional logic:

```tsx
import { TextInput } from '@ledgerhq/ldls-ui-react';

function MyComponent() {
  const [value, setValue] = React.useState('');

  return (
    <TextInput
      label='Search'
      value={value}
      onChange={(e) => setValue(e.target.value)}
      onClear={() => {
        // Default clearing happens automatically
        // Add your custom logic here
        analytics.track('search_cleared');
      }}
    />
  );
}
```

### With Custom Right Element

You can add custom elements to the right side of the input.

> **Note:** Define reusable components for better organization and performance:

```tsx
import { TextInput } from '@ledgerhq/ldls-ui-react';
import { InformationFill, SparksFill } from '@ledgerhq/ldls-ui-react/symbols';

// Action button component
const GeneratePasswordButton = () => (
  <button
    type='button'
    onClick={() => alert('Generate password')}
    aria-label='Generate random password'
  >
    <SparksFill size={20} className='text-muted' />
  </button>
);

function MyComponent() {
  const [value, setValue] = React.useState('');

  return (
    <div className='space-y-16'>
      <TextInput
        label='Password'
        type='password'
        value={value}
        onChange={(e) => setValue(e.target.value)}
        suffix={<GeneratePasswordButton />}
      />
    </div>
  );
}
```

> ‚ö†Ô∏è **Important:** The clear button appears automatically when input has content and will take priority over your `suffix`. Use `hideClearButton={true}` if you need persistent right-side content! üîÑ

### With Error State

The Input component supports error states and messages:

```tsx
import { TextInput } from '@ledgerhq/ldls-ui-react';

function MyComponent() {
  const [value, setValue] = React.useState('');
  const [error, setError] = React.useState(false);

  const handleChange = (e) => {
    const newValue = e.target.value;
    setValue(newValue);
    setError(newValue.length < 3);
  };

  return (
    <TextInput
      label='Username'
      value={value}
      onChange={handleChange}
      aria-invalid={error}
      errorMessage={error ? 'Must be at least 3 characters' : undefined}
    />
  );
}
```

> **Note:** Error message are optional. Use `errorMessage` to display an error message below the input.

## ‚ö†Ô∏è Label vs Placeholder

**Important:** Do not combine `label` and `placeholder` props together. They will visually overlap and create a poor user experience.

The Input component uses floating labels that animate from inside the input field. Using both simultaneously causes visual conflicts.

### ‚úÖ Correct Usage

```tsx
// Use floating label (recommended approach)
<TextInput
  label="Email Address"
  value={email}
  onChange={(e) => setEmail(e.target.value)}
/>

// OR use placeholder (alternative approach)
<TextInput
  placeholder="Enter your email address"
  value={email}
  onChange={(e) => setEmail(e.target.value)}
/>
```

### ‚ùå Incorrect Usage

```tsx
// DON'T DO THIS - causes visual overlap
<TextInput
  label='Email Address'
  placeholder='Enter your email address' // This will overlap with the label
  value={email}
  onChange={(e) => setEmail(e.target.value)}
/>
```

## Do's and Don'ts

With Custom Right Element

### Value Management

‚úÖ **Do**

```tsx
// Use controlled input pattern
const [value, setValue] = useState('');
<TextInput
  value={value}
  onChange={(e) => setValue(e.target.value)}
/>

// Or use uncontrolled inputs (also valid)
<TextInput defaultValue="initial value" />

// Uncontrolled with ref access
const inputRef = useRef<HTMLInputElement>(null);
<TextInput ref={inputRef} defaultValue="" />

// Clear button appears automatically - hideClearButton is false by default
<TextInput
  value={value}
  onChange={handleChange}
/>

// Use onClear to extend default clear behavior with custom logic
<TextInput
  value={value}
  onChange={handleChange}
  onClear={() => {
    // Default clearing happens automatically
    customClearLogic();
  }}
/>

// Hide clear button when needed
<TextInput
  value={value}
  onChange={handleChange}
  hideClearButton
/>

// Use aria-invalid for error states
<TextInput
  value={value}
  onChange={handleChange}
  aria-invalid={hasError}
  errorMessage={hasError ? 'Invalid input' : undefined}
/>
```

‚ùå **Don't**

```tsx
// Don't create custom clear buttons - use the built-in one

<TextInput
  value={value}
  onChange={handleChange}
  suffix={<Button onClick={() => setValue('')}>Clear</Button>}
/>

// Don't manually clear the value in onClear - it happens automatically

<TextInput
  value={value}
  onChange={handleChange}
  onClear={() => setValue('')} // Redundant - clearing happens by default
/>

// Don't use custom error props

<TextInput error={true} errorText="Invalid input" />
```

### Layout and Styling

The Input component takes the **full width** of its parent container by default. You can control the width using `className` (preferred) or wrapper containers:

```tsx
// ‚úÖ Preferred: Direct width control
<TextInput label="Email" className="max-w-md" />

// ‚úÖ Responsive width control
<TextInput label="Email" className="w-full md:max-w-md" />

// Alternative: Container wrapper
<div className="max-w-md">
  <TextInput label="Email" />
</div>

// Full width in form (default behavior)
<form>
  <TextInput label="Search products..." />
</form>
```

‚úÖ **Do**

```tsx
// Use className for input-specific styling
<TextInput className="heading-0" label="Title" />

// Use className for layout and width control (preferred)
<TextInput label="Email" className="max-w-md" />

// Use className for responsive design
<TextInput label="Email" className="w-full md:max-w-lg" />
```

‚ùå **Don't**

```tsx
// Don't override core input styling
<TextInput className="bg-white border-gray-300" />

// Don't modify internal padding/spacing
<TextInput className="px-6 py-4" />

// Don't override typography
<TextInput className="body-4" />

// Don't modify hover/focus states
<TextInput className="hover:border-accent" />
```

### Performance Considerations

‚úÖ **Do**

```tsx
// Import specific icons
import { InformationFill } from '@ledgerhq/ldls-ui-react/symbols';

// Memoize complex right elements
const InfoButton = React.memo(() => (
  <button
    type='button'
    aria-label='Show information'
    className='rounded-full p-2 hover:bg-muted-hover'
  >
    <InformationFill size={20} className='text-muted' />
  </button>
));

<TextInput suffix={<InfoButton />} />;

// Use stable callbacks for extending clear behavior
const handleCustomClear = useCallback(() => {
  // Default clearing happens automatically
  customClearLogic();
}, []);
<TextInput onClear={handleCustomClear} />;
```

‚ùå **Don't**

```tsx
// Don't import all icons
import * as Icons from '@ledgerhq/ldls-ui-react/symbols';

// Don't manually clear in onClear - it's automatic
<TextInput onClear={() => setValue('')} /> // Redundant

// Don't create new functions in render for extending behavior
<TextInput onClear={() => { customLogic(); }} /> // Use useCallback instead

// Don't create complex elements inline
<TextInput
  suffix={
    <ComplexComponent>
      <NestedComponents />
    </ComplexComponent>
  }
/>
```

</Tab>
</CustomTabs>

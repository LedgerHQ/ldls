import { Meta, Canvas, Controls } from '@storybook/addon-docs/blocks';
import * as TextInputStories from './TextInput.stories';
import { TextInput } from './TextInput';
import { CustomTabs, Tab } from '../../../../.storybook/components';
import { DoVsDontRow, DoBlockItem, DontBlockItem } from '../../../../.storybook/components/DoVsDont';
import CommonRulesDoAndDont from '../../../../.storybook/components/DoVsDont/CommonRulesDoAndDont.mdx';

<Meta title='Input/TextInput' of={TextInputStories} />

# ⌨️ TextInput

<CustomTabs>
  <Tab label="Overview">

## Introduction

Input fields are essential form elements that enable users to enter and edit text. This React Native component features a floating label, error states, and an automatic clear button for enhanced user experience across mobile platforms.
It also provides the ability to add custom elements on the right side of the input.

> View in [Figma](https://www.figma.com/design/JxaLVMTWirCpU0rsbZ30k7/2.-Components-Library?node-id=6375-6974&m=dev).

> ⚠️ **Note on Web Preview:** The Storybook preview below may display visual inconsistencies as certain React Native APIs (such as Reanimated animations) cannot be fully translated to web environments. While the component's functionality should accurately represent the native implementation, it may not render as intended. For the complete native experience, please refer to the component on an actual iOS or Android device.

<Canvas of={TextInputStories.Base} />
<Controls of={TextInputStories.Base} />

## Anatomy

> **Layout:** The Input component takes the full width of its container by default. You can control the width by using the `style` prop or by wrapping in a container.

### Floating Label

The label text automatically floats above the input when content is entered, providing a clean and modern interface.

<Canvas of={TextInputStories.WithContent} />

### Clear Button

A clear button (×) appears **automatically** when input has content.

> **Note:** The clear button only clears the input content/value. It does not clear error states - you must handle error state clearing separately in your component logic.

#### **Hiding the Clear Button**

Use `hideClearButton` to prevent the clear button from appearing.

<Canvas of={TextInputStories.WithHiddenClearButton} />

#### **Extending the Clear Behavior**

Use `onClear` to extend the default clear behavior with custom logic.

<Canvas of={TextInputStories.WithClearCallback} />

### Error State

The input supports error handling through `errorMessage` which displays an error message below the input with error styling including a red border and text color.

<Canvas of={TextInputStories.WithError} />

The error message will be automatically:

- Connected to the input
- Displayed with a warning icon
- Styled in the error color
- Announced by screen readers

### Disabled State

The input can be disabled using the `editable` prop set to `false`.

<Canvas of={TextInputStories.DisabledTextInput} />

### Keyboard Types

The component supports various React Native TextInput keyboard types:

<Canvas of={TextInputStories.EmailKeyboard} />

<Canvas of={TextInputStories.PhoneKeyboard} />

## Controlled vs Uncontrolled

The Input component supports both controlled and uncontrolled usage.

### Uncontrolled (with defaultValue)

Use defaultValue when you don't need to track the input's value in state. The component manages its own internal state.

### Controlled (with value and onChangeText)

Use `value` and `onChangeText` when you want full control of the input's state from your component logic.

## Input Types

The component supports various React Native TextInput content types:

- default (text)
- email-address
- numeric
- phone-pad
- url

Set these using the `keyboardType` prop.

## Accessibility

The Input component follows accessibility best practices:

- Supports screen reader navigation
- Labels are properly associated with inputs
- Error messages are properly announced
- Clear button has an accessible label
- Touch target sizes meet minimum requirements (48px height)

## Best Practices

**Labels**: Always provide clear, descriptive labels

**Error Messages**: Make error messages helpful and actionable

**Validation**: Validate on blur or submit, not on every keystroke

**Clear Button**: Use for optional fields where clearing is helpful

**Types**: Use the appropriate keyboard type for the data being collected

</Tab>
<Tab label="Implementation">

## Setup

Install and set up the library with our [Setup Guide →](?path=/docs/getting-started-setup--docs).

### Basic Usage

```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

function MyComponent() {
  const [value, setValue] = useState('');

  return <TextInput label='Username' value={value} onChangeText={setValue} />;
}
```

> **Note:** Clear button appears automatically when input has content. Use `hideClearButton` to hide it.

#### **Hiding the Clear Button**

Use `hideClearButton` to prevent the clear button from appearing:

```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

function MyComponent() {
  const [value, setValue] = useState('');

  return (
    <TextInput
      label='Username'
      value={value}
      onChangeText={setValue}
      hideClearButton // Clear button will not appear
    />
  );
}
```

#### **Extending the Clear Behavior**

Provide `onClear` to extend the default clear behavior with additional logic:

```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

function MyComponent() {
  const [value, setValue] = useState('');

  return (
    <TextInput
      label='Search'
      value={value}
      onChangeText={setValue}
      onClear={() => {
        // Default clearing happens automatically
        // Add your custom logic here
        analytics.track('search_cleared');
      }}
    />
  );
}
```

### With Error State

The Input component supports error states and messages:

```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

function MyComponent() {
  const [value, setValue] = useState('');
  const [error, setError] = useState('');

  const handleChange = (text: string) => {
    setValue(text);
    setError(text.length < 3 ? 'Must be at least 3 characters' : '');
  };

  return (
    <TextInput
      label='Username'
      value={value}
      onChangeText={handleChange}
      errorMessage={error}
    />
  );
}
```

> **Note:** Error messages are optional. Use `errorMessage` to display an error message below the input.

### With Custom Styling

While the component comes with predefined styles, you can extend them using the `style` prop:

```tsx
<TextInput
  label='Email'
  value={email}
  onChangeText={setEmail}
  style={{ maxWidth: 320 }} // Control width
/>
```

### With Different Keyboard Types

Use the `keyboardType` prop to show the appropriate keyboard:

```tsx
// Email keyboard
<TextInput
  label="Email"
  value={email}
  onChangeText={setEmail}
  keyboardType="email-address"
/>

// Numeric keyboard
<TextInput
  label="Phone"
  value={phone}
  onChangeText={setPhone}
  keyboardType="phone-pad"
/>

// URL keyboard
<TextInput
  label="Website"
  value={website}
  onChangeText={setWebsite}
  keyboardType="url"
/>
```

### Disabled State

Use the `editable` prop to disable the input:

```tsx
<TextInput label='Username' value='johndoe' editable={false} />
```

## Do's and Don'ts

<div style={{ display: 'flex', flexDirection: 'column', gap: 24 }}>
  <DoVsDontRow>
    <DoBlockItem
      title='Use controlled input pattern'
      description='Use value and onChangeText props for controlled input state management'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

const [value, setValue] = useState('');

<TextInput
  label='Email'
  value={value}
  onChangeText={setValue}
/>
```

    </DoBlockItem>
    <DontBlockItem
      title="Don't mix controlled and uncontrolled patterns"
      description='Avoid using both value and defaultValue props together'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

const [value, setValue] = useState('');

<TextInput
  label='Email'
  value={value}
  defaultValue='initial'
  onChangeText={setValue}
/>
```

    </DontBlockItem>

  </DoVsDontRow>

  <DoVsDontRow>
    <DoBlockItem
      title='Use onClear for custom logic only'
      description='Let the component handle clearing automatically, add onClear only for additional logic'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

const [value, setValue] = useState('');

<TextInput
  label='Search'
  value={value}
  onChangeText={setValue}
  onClear={() => {
    // Default clearing happens automatically
    analytics.track('search_cleared');
  }}
/>
```

    </DoBlockItem>
    <DontBlockItem
      title="Don't manually clear value in onClear"
      description='Value clearing happens automatically - no need to call setValue'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';
import { useState } from 'react';

const [value, setValue] = useState('');

<TextInput
  label='Search'
  value={value}
  onChangeText={setValue}
  onClear={() => setValue('')}
/>
```

    </DontBlockItem>

  </DoVsDontRow>

  <DoVsDontRow>
    <DoBlockItem
      title='Always provide labels'
      description='Use label prop to provide clear, descriptive labels for inputs'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';

<TextInput
  label='Email Address'
  value={email}
  onChangeText={setEmail}
/>
```

    </DoBlockItem>
    <DontBlockItem
      title="Don't use placeholder as label replacement"
      description='Placeholder text disappears when typing - use label prop instead'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';

<TextInput
  placeholder='Enter your email'
  value={email}
  onChangeText={setEmail}
/>
```

    </DontBlockItem>

  </DoVsDontRow>

  <DoVsDontRow>
    <DoBlockItem
      title='Use appropriate keyboard types'
      description='Provide the right keyboardType to show contextually appropriate keyboards'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';

<TextInput
  label='Email'
  value={email}
  onChangeText={setEmail}
  keyboardType='email-address'
/>
```

    </DoBlockItem>
    <DontBlockItem
      title="Don't use default keyboard for specialized inputs"
      description='Avoid using default keyboard when specialized keyboards would improve UX'
    >

{/* prettier-ignore */}
```tsx
import { TextInput } from '@ledgerhq/lumen-ui-rnative';

<TextInput
  label='Email'
  value={email}
  onChangeText={setEmail}
/>
```

    </DontBlockItem>

  </DoVsDontRow>

  <CommonRulesDoAndDont />
</div>

## Platform Considerations

### iOS Specific

- Input automatically adapts to iOS design guidelines
- Keyboard automatically handles safe area insets
- Respects iOS accessibility settings like Dynamic Type

### Android Specific

- Supports Android keyboard types and input methods
- Handles Android back button interactions appropriately
- Respects Android accessibility services

### Cross-Platform

- Consistent visual appearance across platforms
- Platform-appropriate keyboard behavior
- Unified API regardless of platform
- Animated floating labels work seamlessly on both platforms

</Tab>
</CustomTabs>
